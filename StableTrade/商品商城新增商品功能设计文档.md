# 商品商城新增商品功能设计文档

## 功能概述

在虚拟商品商城页面添加新增商品功能，允许用户创建和管理链上虚拟商品。商品将基于区块链技术，具有唯一性和不可篡改性。

## 技术架构

### 1. 核心文件结构

| 文件路径 | 功能描述 | 主要变更 |
|---------|---------|----------|
| `src/components/VirtualGoodsPage.tsx` | 虚拟商品页面 | 添加新增商品入口和管理功能 |
| `src/components/AddProductModal.tsx` | 新增商品弹窗 | 新增组件，用于创建商品 |
| `src/lib/store.ts` | 全局状态管理 | 添加商品管理相关状态 |
| `src/lib/stablelayer/adapter.ts` | StableLayer 适配器 | 添加商品创建相关 API |
| `src/types/products.ts` | 商品类型定义 | 新增类型定义文件 |

### 2. 数据结构设计

#### 商品类型定义

```typescript
// src/types/products.ts
export interface VirtualProduct {
  id: string
  name: string
  price: string
  usdcAmount: string
  description: string
  icon: string
  tag: string
  creator: string
  createdAt: number
  updatedAt: number
  isListed: boolean
  tokenId?: string // 链上 NFT token ID
  collectionId?: string // 链上集合 ID
}

export type ProductTag = '热门' | '推荐' | '新品' | '稀有' | '限量' | '投资'

export interface CreateProductParams {
  name: string
  price: string
  usdcAmount: string
  description: string
  icon: string
  tag: ProductTag
}
```

#### 全局状态扩展

```typescript
// src/lib/store.ts 扩展
interface ProductState {
  products: VirtualProduct[]
  isLoading: boolean
  error: string | null
  addProduct: (product: VirtualProduct) => void
  updateProduct: (id: string, updates: Partial<VirtualProduct>) => void
  deleteProduct: (id: string) => void
  fetchProducts: () => Promise<void>
}

// 集成到主状态
const useAppStore = create<AppState & ProductState>((set, get) => ({
  // 现有状态...
  
  // 商品相关状态
  products: [],
  isLoading: false,
  error: null,
  
  addProduct: (product) => set((state) => ({
    products: [...state.products, product]
  })),
  
  updateProduct: (id, updates) => set((state) => ({
    products: state.products.map(product => 
      product.id === id ? { ...product, ...updates, updatedAt: Date.now() } : product
    )
  })),
  
  deleteProduct: (id) => set((state) => ({
    products: state.products.filter(product => product.id !== id)
  })),
  
  fetchProducts: async () => {
    set({ isLoading: true, error: null })
    try {
      // 从本地存储或 API 获取商品列表
      const storedProducts = localStorage.getItem('virtual_products')
      const products = storedProducts ? JSON.parse(storedProducts) : []
      set({ products, isLoading: false })
    } catch (error) {
      set({ error: 'Failed to fetch products', isLoading: false })
    }
  }
}))
```

## 功能设计

### 1. 新增商品入口

在 `VirtualGoodsPage.tsx` 中添加新增商品按钮：

```typescript
// 在页面顶部添加
<div className="flex justify-between items-center mb-8">
  <h1 className="text-4xl md:text-5xl font-bold">虚拟商品商城</h1>
  <Button className="btn-gradient" onPress={openAddProductModal}>
    ➕ 新增商品
  </Button>
</div>
```

### 2. 新增商品弹窗

创建 `AddProductModal.tsx` 组件：

```typescript
import { useState } from 'react'
import { Button, Input, Textarea, Select, Modal } from '@heroui/react'
import { useAppStore } from '../lib/store'
import { ProductTag } from '../types/products'

interface AddProductModalProps {
  isOpen: boolean
  onClose: () => void
}

export function AddProductModal({ isOpen, onClose }: AddProductModalProps) {
  const [formData, setFormData] = useState({
    name: '',
    price: '',
    usdcAmount: '',
    description: '',
    icon: '',
    tag: '新品' as ProductTag
  })
  
  const addProduct = useAppStore((state) => state.addProduct)
  const address = useAppStore((state) => state.address)

  const handleSubmit = async () => {
    if (!address) return

    const newProduct: any = {
      id: `product_${Date.now()}`,
      ...formData,
      creator: address,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      isListed: true
    }

    // 添加到状态
    addProduct(newProduct)
    
    // 保存到本地存储
    const storedProducts = JSON.parse(localStorage.getItem('virtual_products') || '[]')
    storedProducts.push(newProduct)
    localStorage.setItem('virtual_products', JSON.stringify(storedProducts))

    onClose()
  }

  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }))
  }

  return (
    <Modal isOpen={isOpen} onClose={onClose} title="新增虚拟商品">
      <div className="space-y-6">
        {/* 表单字段 */}
        <div>
          <label className="text-sm font-semibold mb-2 block">商品名称</label>
          <Input
            placeholder="输入商品名称"
            value={formData.name}
            onChange={(e) => handleChange('name', e.target.value)}
          />
        </div>
        
        <div>
          <label className="text-sm font-semibold mb-2 block">价格 (USDC)</label>
          <Input
            placeholder="1000"
            value={formData.usdcAmount}
            onChange={(e) => {
              handleChange('usdcAmount', e.target.value)
              handleChange('price', `${e.target.value} USDC`)
            }}
          />
        </div>
        
        <div>
          <label className="text-sm font-semibold mb-2 block">商品描述</label>
          <Textarea
            placeholder="输入商品描述"
            value={formData.description}
            onChange={(e) => handleChange('description', e.target.value)}
          />
        </div>
        
        <div>
          <label className="text-sm font-semibold mb-2 block">商品图标</label>
          <Input
            placeholder="输入 emoji 图标，如 🥇"
            value={formData.icon}
            onChange={(e) => handleChange('icon', e.target.value)}
          />
        </div>
        
        <div>
          <label className="text-sm font-semibold mb-2 block">商品标签</label>
          <Select
            options={[
              { value: '热门', label: '热门' },
              { value: '推荐', label: '推荐' },
              { value: '新品', label: '新品' },
              { value: '稀有', label: '稀有' },
              { value: '限量', label: '限量' },
              { value: '投资', label: '投资' }
            ]}
            value={formData.tag}
            onChange={(value) => handleChange('tag', value)}
          />
        </div>
        
        <div className="flex gap-4 justify-end">
          <Button className="btn-ghost" onPress={onClose}>
            取消
          </Button>
          <Button 
            className="btn-gradient" 
            onPress={handleSubmit}
            isDisabled={!formData.name || !formData.usdcAmount || !formData.description}
          >
            创建商品
          </Button>
        </div>
      </div>
    </Modal>
  )
}
```

### 3. 商品管理功能

在商品卡片上添加管理按钮：

```typescript
// VirtualGoodsPage.tsx 中的商品卡片
<div className="glass-card rounded-xl p-5 cursor-pointer">
  {/* 商品信息 */}
  
  {/* 管理按钮 */}
  {product.creator === address && (
    <div className="flex gap-2 mt-4">
      <Button 
        className="flex-1 btn-ghost"
        onPress={() => handleEditProduct(product)}
      >
        编辑
      </Button>
      <Button 
        className="flex-1 btn-danger"
        onPress={() => handleDeleteProduct(product.id)}
      >
        删除
      </Button>
    </div>
  )}
</div>
```

### 4. 链上集成

#### 商品铸造为 NFT

```typescript
// src/lib/stablelayer/adapter.ts 扩展
export async function buildMintProductTx({
  suiClient,
  sender,
  name,
  description,
  imageUrl
}: {
  suiClient: any
  sender: string
  name: string
  description: string
  imageUrl: string
}) {
  const tx = new Transaction()
  
  // 构建 NFT 铸造交易
  // 这里需要根据实际的 NFT 合约来实现
  
  return { tx }
}
```

#### 商品上架/下架

```typescript
// src/lib/stablelayer/adapter.ts 扩展
export async function buildListProductTx({
  suiClient,
  sender,
  tokenId,
  price
}: {
  suiClient: any
  sender: string
  tokenId: string
  price: string
}) {
  const tx = new Transaction()
  
  // 构建商品上架交易
  
  return { tx }
}
```

## 界面设计

### 1. 新增商品入口

在虚拟商品商城页面顶部添加「新增商品」按钮：

- **位置**：页面标题右侧
- **样式**：渐变按钮，带有加号图标
- **权限**：仅当钱包连接时显示

### 2. 新增商品弹窗

- **布局**：模态弹窗，居中显示
- **表单字段**：
  - 商品名称（必填）
  - 价格（USDC，必填）
  - 商品描述（必填）
  - 商品图标（emoji，可选）
  - 商品标签（下拉选择，可选）
- **操作按钮**：
  - 取消
  - 创建商品（仅当必填字段填写完整时可点击）

### 3. 商品管理界面

- **管理按钮**：
  - 编辑：修改商品信息
  - 删除：移除商品
  - 上架/下架：控制商品可见性
- **权限控制**：
  - 仅商品创建者可看到管理按钮
  - 显示创建者标识

### 4. 链上操作反馈

- **交易状态**：显示链上操作的实时状态
- **成功/失败提示**：操作完成后的反馈
- **链上链接**：提供查看链上商品的链接

## 操作流程

### 1. 新增商品流程

1. **点击新增商品**：
   - 点击页面顶部的「新增商品」按钮
   - 确保钱包已连接

2. **填写商品信息**：
   - 输入商品名称
   - 设置商品价格（USDC）
   - 编写商品描述
   - 选择商品图标（emoji）
   - 选择商品标签

3. **提交创建**：
   - 点击「创建商品」按钮
   - 确认钱包签名（如果需要链上操作）
   - 等待操作完成

4. **查看结果**：
   - 商品成功添加到列表
   - 显示成功提示
   - 可在商品列表中查看新商品

### 2. 管理商品流程

1. **找到商品**：
   - 在商品列表中找到自己创建的商品
   - 商品卡片下方会显示管理按钮

2. **执行管理操作**：
   - **编辑**：修改商品信息
   - **删除**：移除商品
   - **上架/下架**：控制商品可见性

3. **确认操作**：
   - 点击操作按钮
   - 确认操作（如果是删除等危险操作）
   - 等待操作完成

4. **查看结果**：
   - 操作成功后更新商品状态
   - 显示操作结果提示

## 技术实现要点

### 1. 本地存储

- 使用 localStorage 存储商品数据
- 提供基础的 CRUD 操作
- 模拟后端功能，便于快速验证

### 2. 区块链集成

- 可选的链上 NFT 铸造
- 商品元数据上链
- 交易状态跟踪

### 3. 权限控制

- 基于钱包地址的权限验证
- 仅商品创建者可管理商品
- 防止未授权操作

### 4. 性能优化

- 商品列表懒加载
- 表单验证优化
- 状态管理优化

### 5. 错误处理

- 表单验证错误
- 链上操作错误
- 权限错误
- 网络错误

## 安全性考虑

1. **钱包验证**：确保操作来自正确的钱包地址
2. **输入验证**：防止恶意输入和 XSS 攻击
3. **交易签名**：所有链上操作需要用户确认
4. **权限检查**：防止未授权的商品管理操作
5. **数据加密**：敏感信息的安全存储

## 兼容性考虑

1. **浏览器兼容性**：支持主流现代浏览器
2. **钱包兼容性**：支持主流 Sui 钱包
3. **响应式设计**：适配不同屏幕尺寸
4. **网络环境**：支持不同网络速度

## 测试计划

### 1. 功能测试

- 新增商品功能
- 编辑商品功能
- 删除商品功能
- 上架/下架功能
- 权限控制
- 链上集成

### 2. 边界测试

- 空表单提交
- 无效价格输入
- 重复商品名称
- 网络中断
- 钱包断开连接

### 3. 性能测试

- 商品列表加载速度
- 表单提交响应时间
- 链上操作处理时间
- 内存使用情况

## 未来扩展

1. **商品分类**：添加商品分类功能
2. **搜索筛选**：实现商品搜索和筛选
3. **批量操作**：支持批量管理商品
4. **商品统计**：提供销售和库存统计
5. **用户收藏**：允许用户收藏商品
6. **拍卖功能**：支持商品拍卖
7. **多链支持**：扩展到其他区块链
8. **API 集成**：对接后端 API 服务

## 实现优先级

1. **核心功能**：新增商品、编辑、删除
2. **用户体验**：界面设计、错误处理
3. **链上集成**：NFT 铸造、交易
4. **高级功能**：搜索、分类、统计
5. **性能优化**：加载速度、响应时间
6. **安全性**：权限控制、数据加密

## 结论

本设计方案提供了一个完整的商品商城新增商品功能实现路径，从前端界面到后端逻辑，再到区块链集成。通过模块化的设计和清晰的流程，用户将能够方便地创建和管理链上虚拟商品，为平台增加更多价值和互动性。